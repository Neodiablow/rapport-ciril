\begin{figure}[H]
\center
\includegraphics[width=0.2\textwidth]{logstash.png}
\label{fig:logstashlogo.png}
\end{figure}
\section{Présentation de Logstash}

\subsection{Pourquoi Logstash?}
Bien qu'un administrateur système compétent soit capable d'analyser de façon rapide 
et efficace les logs d'une machine (à l'aide deperl+awk+sed+tail+grep), cette méthode
est fastidieuse. De plus, face à des dizaines/milliers de machines (virtuelles aussi), 
cette méthode n'est plus applicable, elle ne peut pas passer à l'échelle.
Il est actuellement fréquent (cloud, applications multicouche, \ldots) que les logs 
d'une seule machine ne suffise plus à diagnostiquer le problème auquel on est confronté.

\subsection{Fonctionnement interne}
L'utilisation de logstash est un pipeline qui s'articule autour de 3 \emph{blocs} 
également appelés \emph{stages} (phase).
\begin{itemize}
    \item   Le bloc : \emph{Inputs} génère des événements à partir des informations reçues
    par logstash en entrée.
    \item   Le bloc : \emph{Filters} modifie, manipule, ces évènements dans logstash
    \item   Le bloc : \emph{Outputs} envoie les évènements de logstash vers leur 
    prochaine destination.
\end{itemize}

Cette façon de fonctionner peut faire penser à \emph{iptables}.

Logstash est un logiciel développé en Jruby\footnote{sauf mention contraire, on supposera
dans ce rapport que logstash est développé en ruby}. Le passage d'une phase 
à l'autre est implémenté via les \emph{SizedQueue} de ruby. Elles sont dimensionnées 
pour contenir 20 éléments\footnote{appelés messages lorsqu'on parle de queues, 
on parle bien ici des \textbf{événements} logstash}, ce n'est pas paramétrable sans 
modifier le code source, c'est un choix délibéré. Ces queues ne sont pas conçues 
pour stocker des données à long terme. On verra plus tard que ce la justifie l'utilisation
d'un \textit{buffer}, comme \emph{Redis}\footnote{voir la sous partie sur la tolérence
de pannes ainsi que le chapitre consacré à Redis}.


Chaque bloc est composé d'une multitude de plugins. Ce sont des modules indépendants
qui peuvent également fonctionner en conjonction les uns des autres.

Il est, par exemple, possible de configure le bloc \emph{inputs} pour utiliser 
plusieurs fois le plugin "file" (on imagine pour des cas d'utilisation différents) 
et de se servir dans le même temps d'un autre plugin du bloc \emph{inputs} : stdin 
qui prendra typiquement en entrée le clavier.


Il est possible d'implémenter de nouveaux plugins en ruby afin de les ajouter à
notre logstash.

Il existe également un \textit{pseudo-bloc} qui peut s'insérer dans les autres, ce 
bloc, \emph{codec} permet la de gérer la \textit{représentation des données} c'est 
à dire qu'un codec est capable de lire ou d'écrire dans une syntaxe particulière 
comme par exemple rubydebug, collectd, ou, bien plus intéressant pour nous, netflow.

%wtf why?
%et les types ??


%Explications supplémentaires sur les filtres
% les plugins et les patterns par défaut?

\subsubsection{Tolérance de pannes}
Vos logs sont \textbf{importants}, c'est la raison d'être de Logstash, il ne souhaite 
pas que vous en perdiez le moindre à cause d'un problème réseau ou d'une défaillance
quelconque rendant la destination indisponible.
%cf pipeline.rb et base.rb dans github
Lors d'une indisponibilité, les plugins outputs tentent de renvoyer les événements 
vers leur destination. Si ce n'est pas possible le plugin arrête de lire sa queue 
tant que le message n'a pas pu être envoyé. Par effet domino, une fois la queue 
\textit{filtre => output} remplie, le bloc filtre, ne pouvant plus envoyer de nouveaux 
messages à la queue \textit{FO}. Le plugin du bloc filtre va également retenter 
d'envoyer ses messages, et refuser en attendant de lire les nouveaux arrivant dans 
la queue \textit{input => filtre}.
Si cette dernière venait à se remplir c'est le Logstash tout entier qui refuserait de 
traiter de nouvelles informations. Dans le meilleur des mondes, les expéditeurs de
données se comporterais comme logstash et attendraient patiemment que le problème
se résolve, malheureusement cela n'est pas toujours possible, particulièrement dans
nos problématiques d'où l'importance d'un Redis en amont (ou en aval) afin de 
faire tampon.\footnote{Il existe d'autres outils que Redis, (dont ce n'est pas la fonction
principale) pour réaliser ce travail, ils sont plus adapté mais aussi moins documentés
dans leur utilisation avec logstash.}

\subsubsection{Multithread}
Attention ces informations sont pour le moment, \date{Jeudi 16 Avril}, correctes 
mais sont amenées à changer, notamment concernant les outputs.

Chaque plugin utilise input un \gls{thread}, cela permet d'éviter les engorgements si  
certaines entrées sont plus longues à traiter que d'autres.

En le bloc filtre entier n'utilise par défaut qu'un seul thread, mais il est possible 
d'augmenter le nombre de threads affectés au traitement des filtres avec le \gls{flag}
-w lors du démarrage de Logstash.

À l'heure actuelle le bloc output de logstash ne peut utiliser qu'un seul thread.
Il lit donc sa queue de façon séquentielle.


\section{Installation}
%Sur debian il n'existe pas de paquet deb déjà fait, et le seul prérequis 
%est d'avoir une version de java > 1.7.0\_45
%Pour télécharger et installer
%curl -O https://download.elasticsearch.org/logstash/logstash/logstash-1.4.2.tar.gz
%
%tar zxvf logstash-1.4.2.tar.gz
%
%script before-install.sh
%
%sudo cp -r /home/\$USER/Downloads/logstash-1.4.2 /opt/logstash
%
%sudo mkdir /var/log/logstash
%
%script after-install.sh
%
%cd logstash-1.4.2
%
%Création du path
%
%export PATH+=:/opt/logstash
%
%Dautres méthodes d'installation

%Ensuite un simple git clone https://github.com/elastic/logstash.git
%nous permet de récupérer le dépot stable le plus récent.
%Enfin des scripts d'installation sont disponible
%dans logstash/pkg/debian



Sur Debian jessie il n'existe pas de paquet officiel logstash maintenu. Il existe 
en revanche un paquet tiers\fnu{https://download.elastic.co/logstash/logstash/packages/debian/logstash\_1.4.2-1-2c0f5a1\_all.deb}
fourni par l'éditeur du logiciel. Le dit paquet n'est pas de très bonne facture  
puisqu'il nécessite l'ajout de dépendances manuelles\footnote{wget paquet, 
dpkg -i paquet, apt-get install -f} ainsi qu'un rechargement de 
la configuration des services : \emph{systemctl daemon-reload}.

Les dépendances nécessaires sont \emph{jruby} et \emph{openjdk-7-jre}, les mêmes 
que pour elasticsearch.

Une autre manière de réaliser l'installation est d'ajouter les dépots logstash à 
\ipath{/etc/apt/source.list.d/logstash.list.d/logstash.list}

\begin{lstlisting}[style=code,label={lst:ajoutdepotlogstash}]
deb https://packages.elasticsearch.org/logstash/1.4/debian stable main
\end{lstlisting}

et évidemment la clef qui va bien\footnote{permet d'authentifier les paquets téléchargés
(cf:SecureApt)}

\begin{lstlisting}[style=code,label={lst:ajoutclefdepotlogstash}]
wget -qO - https://packages.elasticsearch.org/GPG-KEY-elasticsearch | sudo apt-key add -
\end{lstlisting}

\subsection{Configurations}
Il est d'usage dans une installation \textit{propre} de créer un utilisateur spécifique
à notre utilisation. C'est également le cas dans notre paquet. L'administrateur 
système doit donner à cet utilisateur, nouvellement créer les droits nécessaire 
pour qu'il puisse faire son travail correctement correctement. Dans le cadre de 
l'analyse de log faire de l'utilisateur logstash un membre du groupe \emph{adm}, 
le groupe d'administration de Debian lui permettra par exemple d'avoir accès en 
lecture à la plupart des fichiers de \ipath{/var/log/}.

\subsubsection{Set Capabilities}
Cependant cette façon de faire peut ne pas être suffisante.
Notre utilisation de logstash consiste, entre autre, à centraliser les \gls{logs}. 
Ces derniers sont généralement envoyés par l'intermédiaire de syslog (RFC 5244).
Par défaut syslog utilise le port 514, ce port est inférieur à 1024, et donc \textit{privilégié}.
Aussi seul \emph{root} à le droit d'écouter ces ports. Ajouter notre utilisateur 
logstash au groupe root enlèverait le bénéfice de sécurité obtenu en isolant les 
utilisateurs en fonction de leurs besoins. Nous allons plutôt utiliser les 
\emph{capabilities}\fnu{http://man7.org/linux/man-pages/man7/capabilities.7.html} 
et la commande \emph{setcap}\fnu{https://github.com/elastic/logstash/issues/1587}
\begin{lstlisting}[style=code,label={lst:setcapabilities}]
setcap cap_net_bind_service=+epi /usr/lib/jvm/java-7-openjdk-amd64/jre/bin/java
setcap cap_net_bind_service=+epi /usr/lib/jvm/java-1.7.0-openjdk-amd64/jre/bin/java
\end{lstlisting}
qui permettent à un processus (thread en faite) de ne pas se soumettre à certaines 
vérifications de sécurité du noyau.

\textbf{cap\_net\_bind\_service} permet à un utilisateur non privilégié (non root) 
d'écouter sur les ports privilégiés.

Les informations concernants les autres capabilities existants sont disponible dans
la page de manuel correspondante : \emph{man capabilities}.

\textbf{=+epi} signifie que l'on ajoute une \emph{capapbility} à un fichier. Plus 
précisement \textbf{=+} signifie que l'on écrase les droits précédents pour les remplacer
par les nouveaux. \textbf{e, p} et \textbf{i} sont la gradation de droits que l'on peut 
attribuer à un fichier avec les capabilities. Le droit \textbf{effective} 
\fnu{https://www.kernel.org/pub/linux/libs/security/linux-privs/kernel-2.2/capfaq-0.2.txt}

\begin{lstlisting}[style=code,label={lst:unsetcapabilities}]
setcap cap_net_bind_service=-epi /usr/lib/jvm/java-1.7.0-openjdk-amd64/jre/bin/java
\end{lstlisting}
Pour les enlever.

Enfin, pour rendre le changement permanent, il faut modifier le fichier 

\ipath{/etc/security/capability.conf}.

\subsection{Installation de plugins tiers}
Procédure pour l'installation d'un plugin tiers



\section{Grammaire et conjugaison}

Les fichiers de confs et leurs fonctionnement + interaction entre plugins et etc...



\section{Utilisation basique}

\section{Mon serveur central}



\section{Monter à l'échelle}




